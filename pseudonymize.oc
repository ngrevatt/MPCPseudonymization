#include <stdio.h>
#include <stdlib.h>
#include <obliv.oh>

#include "pseudonymize.h"
#include "dbg.h"

// #include the AES stuff -> how?




void toObliv(protocolIO *io, operson *oFullData, person *fullData, int party)
{
    for(int i = 0;, i < io->numDataRecords; i++) {
        oFullData[i].email = feedOblivChar(fullData[i], party);
        oFullData[i].EUCitizenship = feedOblivChar(fullData[i], party);
        oFullData[i].income = feedOblivChar(fullData[i], party);
    }    
}

void pseudonymize_data(protocolIO * io, struct operson * fullData);
        // ADD AES KEY, also, I am not sure I need the two extra structs

    int n = io->numDataRecords;
    obliv char * tmpEncryptedEmail = char[128]; // this is going to store encrypted emails
    for (int i = 0; i < n; i++) {
        // iterate through both structs and split them into the two kinds of data
        // the values can be OvlivRevealed one by one as they are iteraged through
        // this is how they are saved (?)

        // populate nonidentifiable data
        revealOblivChar(&io->nonIdentifiableData[n].email, fullData[n].email, 1);
        revealOblivInt(&io->nonIdentifiableData[n].EUCitizenship, fullData[n].EUCitizenship, 1);

        // populate pseudonymized data
        // the emails should be encrypted for pseudonymized data
        tmpEncryptedEmail = itoa(n); // placeholder, this should be the encrypted value
        revealOblivChar(&io->pseudonymizedData[n].encryptedEmail, tmpEncryptedEmail, 1);
        revealOblivInt(&io->pseudonymizedData[n].income, fullData[n].income, 1);
        
    }

    // and the pseudonymized array should be shuffled 
    //OvlivReveal the encryption key to party 2
    

void pseudonymize(void * args)
{
    protocolIO *io = (protocolIO*) args;

    // used for loading the data
    struct person * fullData = malloc(sizeof(person) * io->numDataRecords);
    check_mem(fullData, ocCurrentParty());

    // Results 
    //struct operson oPseudonymizedData = malloc(sizeof(person) * io->numDataRecords)
    //struct operson oNonIdentifiableData = malloc(sizeof(person) * io->numDataRecords)
    // !!ADD IN AES Encryption Key

    load_data(io, &fullData, ocCurrentParty());
    //check_input_count (not relevant for this operation, also not relevant for processing
    // because the set intersection does not assume full personal data remains?)

    // like fullData, but with obliv fields (defined in pseudonymize.h)
    struct operson * oFullData = malloc(sizeof(operson) * io->numDataRecords)

    toObliv(io, oFullData, fullData, 1);
    free(fullData);

    pseudonymize_data(io, oFullData); // add oAESEncryptionKey
    free(oFullData);

}
